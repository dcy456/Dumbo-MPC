// Copyright 2020 Consensys Software Inc.
//
// Licensed under the Apache License, Version 2.0 (the "License");
// you may not use this file except in compliance with the License.
// You may obtain a copy of the License at
//
//     http://www.apache.org/licenses/LICENSE-2.0
//
// Unless required by applicable law or agreed to in writing, software
// distributed under the License is distributed on an "AS IS" BASIS,
// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
// See the License for the specific language governing permissions and
// limitations under the License.

// Code generated by consensys/gnark-crypto DO NOT EDIT

package generalized_ped

import (
	"C"
	"crypto/rand"
	"fmt"
	"crypto/sha256"
	"hash"
	// "time"
	"sync"
	"github.com/consensys/gnark-crypto/ecc"
	curve "github.com/consensys/gnark-crypto/ecc/secp256k1"
	"github.com/consensys/gnark-crypto/ecc/secp256k1/fr"

	fiatshamir "github.com/consensys/gnark-crypto/fiat-shamir"
	// "io"
	"math/big"
)

// ProvingKey for committing and proofs of knowledge
type ProvingKey struct {
	Basis []curve.G1Affine
	G []curve.G1Affine
	H []curve.G1Affine
}

// type VerifyingKey struct {
// 	g             curve.G2Affine // TODO @tabaie: does this really have to be randomized?
// 	gRootSigmaNeg curve.G2Affine //gRootSigmaNeg = g^{-1/σ}
// }

func randomFrSizedBytes() ([]byte, error) {
	res := make([]byte, fr.Bytes)
	_, err := rand.Read(res)
	return res, err
}

func randomOnG1() (curve.G1Affine, error) { // TODO: Add to G2.go?
	if gBytes, err := randomFrSizedBytes(); err != nil {
		return curve.G1Affine{}, err
	} else {
		return curve.HashToG1(gBytes, []byte("random on g1"))
	}
}

func Setup(batchsize uint64) (ProvingKey) {

	var pk ProvingKey
	pk.Basis = make([]curve.G1Affine, batchsize)
	pk.G = make([]curve.G1Affine, 1)
	pk.H = make([]curve.G1Affine, 1)
	for i := range pk.Basis {
		pk.Basis[i], _ = randomOnG1()
	} 
	
	pk.G[0], _= randomOnG1()
	pk.H[0], _= randomOnG1()
	return pk
}

func Commit(pk ProvingKey, poly [][]fr.Element)([]curve.G1Affine){
    rows := len(poly)
    cols := len(poly[0])
	basis := make([]curve.G1Affine, rows)
	copy(basis[:rows-1], pk.Basis[:rows-1])
	basis[rows-1].Set(&pk.H[0])


    transposed_poly := make([][]fr.Element, cols)
    for i := range transposed_poly {
        transposed_poly[i] = make([]fr.Element, rows)
    }

    for i, row := range poly {
        for j, val := range row {
            transposed_poly[j][i] = val
        }
    }

	commitment := make([]curve.G1Affine, cols)

	config := ecc.MultiExpConfig{
		NbTasks: 1,
	}
	// for i := 0; i < cols; i++ {
	// 	_, err := commitment[i].MultiExp(basis, transposed_poly[i], config)
	// 	if err != nil {
	// 		fmt.Println("err", err)
	// 	}
	// }

	var wg sync.WaitGroup

	for i := 0; i < cols; i++ {
		wg.Add(1)
		go func(i int) {
			defer wg.Done()

			_, err := commitment[i].MultiExp(basis, transposed_poly[i], config)
			if err != nil {
				fmt.Println("err", err)
			}
		}(i)
	}

	wg.Wait()

	return commitment
}


// TODO @Tabaie get rid of this and use the polynomial package
// eval returns p(point) where p is interpreted as a polynomial
// ∑_{i<len(p)}p[i]Xⁱ
func Eval(p []fr.Element, point fr.Element) (fr.Element) {
	var res_p fr.Element
	n := len(p)
	res_p.Set(&p[n-1])
	for i := n - 2; i >= 0; i-- {
		res_p.Mul(&res_p, &point).Add(&res_p, &p[i])
	}
	return res_p
}

type ProofofAggDlog struct {
	S []fr.Element
	T []fr.Element
	V []curve.G1Affine
	U []curve.G1Affine
}

// this is an implement of Proof of Equality of Aggregated Discrete Logs & Commitments
// (https://eprint.iacr.org/2018/557.pdf)
func ProofofEqualityofAggDlog(Pk ProvingKey, exponents []fr.Element) (ProofofAggDlog, []curve.G1Affine, []fr.Element) {
	ExpLength := len(exponents)

	randomness := make([]fr.Element, ExpLength)
	C := make([]curve.G1Affine, ExpLength)
	
	// for j := 0; j < (ExpLength); j++ {
	// 	randomness[j].SetRandom()
	// 	C[j] = PedCommit(Pk.G[0], Pk.H[0], exponents[j], randomness[j])
	// }
	var wg sync.WaitGroup
	var mu sync.Mutex

	for j := 0; j < ExpLength; j++ {
		wg.Add(1)
		go func(index int) {
			defer wg.Done()

			var random fr.Element
			random.SetRandom()
			C_j := PedCommit(Pk.G[0], Pk.H[0], exponents[index], random)
			mu.Lock()
			randomness[index] = random
			C[index] = C_j
			mu.Unlock()
		}(j)
	}
	wg.Wait()

	// first round
	var proof ProofofAggDlog

	basis := make([]curve.G1Affine, ExpLength)
	copy(basis[:ExpLength-1], Pk.Basis[:ExpLength-1])
	basis[ExpLength-1].Set(&Pk.H[0])

	config := ecc.MultiExpConfig{
		NbTasks: 1,
	}

	var y curve.G1Affine
	_, err := y.MultiExp(basis, exponents, config)
	if err != nil {
		fmt.Println("err", err)
	}

	alpha := make([]fr.Element, ExpLength)
	R := make([]fr.Element, ExpLength)
	for j := 0; j < (ExpLength); j++ {
		alpha[j].SetRandom()
		R[j].SetRandom()
	}

	proof.U = make([]curve.G1Affine, 1)
	_, err = proof.U[0].MultiExp(basis, alpha, config)
	if err != nil {
		fmt.Println("err", err)
	}

	proof.V = make([]curve.G1Affine, ExpLength)
	// for i := 0; i < ExpLength; i++ {
	// 	proof.V[i] = PedCommit(Pk.G[0], Pk.H[0], alpha[i], R[i])
	// }
	for i := 0; i < ExpLength; i++ {
		wg.Add(1)
		go func(index int) {
			defer wg.Done()

			V_i := PedCommit(Pk.G[0], Pk.H[0], alpha[index], R[index])

			mu.Lock()
			proof.V[index] = V_i
			mu.Unlock()
		}(i)
	}

	wg.Wait()

	hf := sha256.New()
	chall, err := deriveChall(y, C, proof.U[0], proof.V, basis, Pk.G[0], hf)
	if err != nil {
		fmt.Println(err)
	}

	proof.S = make([]fr.Element, ExpLength)
	proof.T = make([]fr.Element, ExpLength)

	// for i := 0; i < ExpLength; i++ {
	// 	proof.S[i].Mul(&chall, &exponents[i])
	// 	proof.S[i].Sub(&alpha[i], &proof.S[i])
	// 	proof.T[i].Mul(&chall, &randomness[i])
	// 	proof.T[i].Sub(&R[i], &proof.T[i])
	// }
	for i := 0; i < ExpLength; i++ {
		wg.Add(1)
		go func(index int) {
			defer wg.Done()

			var S_i fr.Element
			S_i.Mul(&chall, &exponents[index])
			S_i.Sub(&alpha[index], &S_i)

			var T_i fr.Element
			T_i.Mul(&chall, &randomness[index])
			T_i.Sub(&R[index], &T_i)

			mu.Lock()
			proof.S[index] = S_i
			proof.T[index] = T_i
			mu.Unlock()
		}(i)
	}

	wg.Wait()

	return proof, C, randomness

}

func VerifyAggDlog(Pk ProvingKey, proof ProofofAggDlog, commitment []curve.G1Affine, T []curve.G1Affine, point fr.Element, t int) bool {

	basis := make([]curve.G1Affine, len(T))
	copy(basis[:len(T)-1], Pk.Basis[:len(T)-1])
	basis[len(T)-1].Set(&Pk.H[0])

	values := make([]fr.Element, t+1)
	for i := 0; i < int(t+1); i++ {
		var temp big.Int
		temp.SetInt64(int64(i))
		values[i].Exp(point, &temp)
	}

	config := ecc.MultiExpConfig{
		NbTasks: 1,
	}

	var y curve.G1Affine
	_, err := y.MultiExp(commitment, values, config)
	if err != nil {
		fmt.Println("y err", err)
		return false
	}

	// check u = y^c \prod basis_i^{s_i}
	hf := sha256.New()
	chall, _ := deriveChall(y, T, proof.U[0], proof.V, basis, Pk.G[0], hf)
	ywithbasis := append([]curve.G1Affine{y}, basis...)
	cwiths := append([]fr.Element{chall}, proof.S...)

	var rhs curve.G1Affine
	_, err = rhs.MultiExp(ywithbasis, cwiths, config)
	if err != nil {
		fmt.Println("rhs_u err", err)
		return false
	}

	if !rhs.Equal(&proof.U[0])  {
		fmt.Println("The check of commitment fails")
		return false
	}

	// v_i = (T_i)^chall g^{s_i} h^{t_i}
	rightbase := make([]curve.G1Affine, 3*len(T))
	rightexpoent := make([]fr.Element, 3*len(T))
	for i := 0; i < len(T); i++ {
		j := i*3 
		rightbase[j].Set(&T[i])
		rightbase[j+1].Set(&Pk.G[0])
		rightbase[j+2].Set(&Pk.H[0])
		rightexpoent[j].Set(&chall)
		rightexpoent[j+1].Set(&proof.S[i])
		rightexpoent[j+2].Set(&proof.T[i])
	}

	var rightside curve.G1Affine
	_, err = rightside.MultiExp(rightbase, rightexpoent, config)
	if err != nil {
		fmt.Println("rightside err", err)
		return false
	}

	var leftside curve.G1Affine
	for i := 0; i < len(T); i++ {
		if i==0 {
			leftside.Set(&proof.V[0])
		} else{
			leftside.Add(&leftside, &proof.V[i])
		}
		
	}

	if !rightside.Equal(&leftside) {
		fmt.Println("The check of commitmentof shares fails")
		return false
	}

	return true
}

// deriveChall derives a challenge using Fiat Shamir to fold proofs.
func deriveChall(y curve.G1Affine, C []curve.G1Affine, u curve.G1Affine, v []curve.G1Affine, basis []curve.G1Affine, g curve.G1Affine, hf hash.Hash) (fr.Element, error) {

	// derive the challenge gamma, binded to the point and the commitments
	fs := fiatshamir.NewTranscript(hf, "gamma")
	mergeList := append(append(append([]curve.G1Affine{}, C...), v...), basis...)
    mergeList = append(mergeList, y, u, g)


	for i := range mergeList {
		temp := mergeList[i].RawBytes()
		if err := fs.Bind("gamma", temp[:]); err != nil {
			return fr.Element{}, err
		}
	}

	gammaByte, err := fs.ComputeChallenge("gamma")
	if err != nil {
		return fr.Element{}, err
	}
	var gamma fr.Element
	gamma.SetBytes(gammaByte)

	return gamma, nil
}

func Verify(pk ProvingKey, commitment []curve.G1Affine, eval []fr.Element, point fr.Element, t uint64) bool {
	basis := make([]curve.G1Affine, len(eval))
	copy(basis[:len(eval)-1], pk.Basis[:len(eval)-1])
	basis[len(eval)-1].Set(&pk.H[0])

	config := ecc.MultiExpConfig{
		NbTasks: 1,
	}

	var rhs curve.G1Affine
	_, err := rhs.MultiExp(basis, eval, config)
	if err != nil {
		fmt.Println("rhs err", err)
		return false
	}

	var lhs curve.G1Affine
	values := make([]fr.Element, t+1)
	for i := 0; i < int(t+1); i++ {
		var temp big.Int
		temp.SetInt64(int64(i))
		values[i].Exp(point, &temp)
	}

	_, err = lhs.MultiExp(commitment, values, config)
	if err != nil {
		fmt.Println("lhs err", err)
		return false
	}
	
	if lhs != rhs{
		fmt.Println("Verification fails")
		return false
	}
	return true
}

func PedCommit(g curve.G1Affine, h curve.G1Affine, m fr.Element, r fr.Element) curve.G1Affine {
	var result curve.G1Affine
	var temp curve.G1Affine
	var mBigInt big.Int
	m.BigInt(&mBigInt)
	temp.ScalarMultiplication(&g, &mBigInt)

	var rBigInt big.Int
	r.BigInt(&rBigInt)
	result.ScalarMultiplication(&h, &rBigInt)
	result.Add(&result, &temp)
	return result
}

// deriveGamma derives a challenge using Fiat Shamir to fold proofs.
func Derivechall(digests []curve.G1Affine, hf hash.Hash) (fr.Element, error) {

	// derive the challenge gamma, binded to the point and the commitments
	fs := fiatshamir.NewTranscript(hf, "challenge")
	for i := range digests {
		temp :=digests[i].RawBytes()
		if err := fs.Bind("challenge", temp[:]); err != nil {
			return fr.Element{}, err
		}
	}
	gammaByte, err := fs.ComputeChallenge("challenge")
	if err != nil {
		return fr.Element{}, err
	}
	var gamma fr.Element
	gamma.SetBytes(gammaByte)

	return gamma, nil
}

type ProdProof struct {
	G1proofs []curve.G1Affine

	Frproofs []fr.Element
}

// prodproofs:
// beta, gamma, delta: prodproofs.G1proofs[0], prodproofs.G1proofs[1], prodproofs.G1proofs[2]
// z[1], ..., z[5]: prodproofs.Frproofs[0], ..., prodproofs.Frproofs[4]
func Prodproof(Pk ProvingKey, a fr.Element, a_aux fr.Element, b fr.Element, b_aux fr.Element,
	c fr.Element, c_aux fr.Element, T_a curve.G1Affine, T_b curve.G1Affine, T_c curve.G1Affine) ProdProof {
	
	gh := make([]curve.G1Affine, 2)
	gh[0].Set(&Pk.G[0])
	gh[1].Set(&Pk.H[0])
	e := make([]fr.Element, 5)
	for i := 0; i < 5; i++ {
		e[i].SetRandom()
	}	

	// proofs[0]: beta
	// proofs[1]: gamma
	// proofs[2]: delat
	e_list := make([]fr.Element, 2)
	proofs := make([]curve.G1Affine, 3)
	e_list[0].Set(&e[0])
	e_list[1].Set(&e[1])
	proofs[0].MultiExp(gh, e_list, ecc.MultiExpConfig{})

	e_list[0].Set(&e[2])
	e_list[1].Set(&e[3])
	proofs[1].MultiExp(gh, e_list, ecc.MultiExpConfig{})

	gh[0].Set(&T_a)
	e_list[0].Set(&e[2])
	e_list[1].Set(&e[4])
	proofs[2].MultiExp(gh, e_list, ecc.MultiExpConfig{})

	hf := sha256.New()
	transcript, err := Derivechall(proofs, hf)
	if err != nil {
		fmt.Println(err)
	}

	z := make([]fr.Element, 5)
	z[0].Mul(&transcript, &a)
	z[0].Add(&z[0], &e[0])

	z[1].Mul(&transcript, &a_aux)
	z[1].Add(&z[1], &e[1])

	z[2].Mul(&transcript, &b)
	z[2].Add(&z[2], &e[2])

	z[3].Mul(&transcript, &b_aux)
	z[3].Add(&z[3], &e[3])

	z[4].Mul(&a_aux, &b)
	z[4].Sub(&c_aux, &z[4])
	z[4].Mul(&transcript, &z[4])
	z[4].Add(&z[4], &e[4])

	var prodproofs ProdProof
	prodproofs.G1proofs = make([]curve.G1Affine, 3)
	prodproofs.Frproofs = make([]fr.Element, 5)
	copy(prodproofs.G1proofs, proofs)
	copy(prodproofs.Frproofs, z)
	
	return prodproofs
}

func BatchProductVerify(g curve.G1Affine, h curve.G1Affine,
	prodproof []ProdProof, T_ab []curve.G1Affine,
	T_c []curve.G1Affine) bool {
	batchsize := (len(T_ab) - 1) / 2
	hf := sha256.New()
	transcript := make([]fr.Element, batchsize)
	for i := 0; i < batchsize; i++ {
		transcript[i], _ = Derivechall(prodproof[i].G1proofs, hf)
	}

	// leftside batch computation
	leftside_base := make([][]curve.G1Affine, 3)
	leftside_exponential := make([][]fr.Element, 3)
	for i := 0; i < 3; i++ {
		leftside_base[i] = make([]curve.G1Affine, 2*batchsize)
		leftside_exponential[i] = make([]fr.Element, 2*batchsize)
	}

	for i := 0; i < batchsize; i++ {
		j := i * 2
		leftside_base[0][j].Set(&prodproof[i].G1proofs[0])
		leftside_base[0][j+1].Set(&T_ab[i])
		leftside_exponential[0][j].SetOne()
		leftside_exponential[0][j+1].Set(&transcript[i])
	}

	for i := 0; i < batchsize; i++ {
		j := i * 2
		leftside_base[1][j].Set(&prodproof[i].G1proofs[1])
		leftside_base[1][j+1].Set(&T_ab[i+batchsize])
		leftside_exponential[1][j].SetOne()
		leftside_exponential[1][j+1].Set(&transcript[i])
	}

	for i := 0; i < batchsize; i++ {
		j := i * 2
		leftside_base[2][j].Set(&prodproof[i].G1proofs[2])
		leftside_base[2][j+1].Set(&T_c[i])
		leftside_exponential[2][j].SetOne()
		leftside_exponential[2][j+1].Set(&transcript[i])
	}

	leftside := make([]curve.G1Affine, 3)

	for i := 0; i < 3; i++ {
		leftside[i].MultiExp(leftside_base[i], leftside_exponential[i], ecc.MultiExpConfig{})
	}

	// rightside batch computation
	rightside_base := make([]curve.G1Affine, 2*batchsize)
	rightside_exponential := make([][]fr.Element, 23)
	for i := 0; i < 2; i++ {
		rightside_exponential[i] = make([]fr.Element, 2*batchsize)
	}

	for i := 0; i < batchsize; i++ {
		j := i * 2
		rightside_base[j].Set(&g)
		rightside_base[j+1].Set(&h)
	}

	for i := 0; i < batchsize; i++ {
		j := i * 2
		rightside_exponential[0][j].Set(&prodproof[i].Frproofs[0])
		rightside_exponential[0][j+1].Set(&prodproof[i].Frproofs[1])
		rightside_exponential[1][j].Set(&prodproof[i].Frproofs[2])
		rightside_exponential[1][j+1].Set(&prodproof[i].Frproofs[3])
	}

	rightside := make([]curve.G1Affine, 3)
	for i := 0; i < 2; i++ {
		rightside[i].MultiExp(rightside_base, rightside_exponential[i], ecc.MultiExpConfig{})
	}

	for i := 0; i < batchsize; i++ {
		j := i * 2
		rightside_base[j].Set(&T_ab[i])
		rightside_exponential[1][j+1].Set(&prodproof[i].Frproofs[4])
	}

	rightside[2].MultiExp(rightside_base, rightside_exponential[1], ecc.MultiExpConfig{})

	for i := 0; i < 3; i++ {
		if !leftside[i].Equal(&rightside[i]) {
			fmt.Println("Product check fails!", i)
			return false
		}
	}

	return true

}

func Prodproofverify(g curve.G1Affine, h curve.G1Affine, 
	prodproof ProdProof, T_a curve.G1Affine, T_b curve.G1Affine, 
	T_c curve.G1Affine) bool {


	computerightside := func(g curve.G1Affine, h curve.G1Affine, frproofs []fr.Element, i int, j int) curve.G1Affine {

		z_list := make([]fr.Element, 2)
		z_list[0].Set(&frproofs[i])
		z_list[1].Set(&frproofs[j])

		gh := make([]curve.G1Affine, 2)
		gh[0].Set(&g)
		gh[1].Set(&h)
		var res curve.G1Affine

		res.MultiExp(gh, z_list, ecc.MultiExpConfig{})
		return res
	}

	var result bool = true
	rightside := make([]curve.G1Affine, 3)
	rightside[0] = computerightside(g, h, prodproof.Frproofs, 0, 1)
	rightside[1] = computerightside(g, h, prodproof.Frproofs, 2, 3)
	rightside[2] = computerightside(T_a, h, prodproof.Frproofs, 2, 4)
	

	computeleftside := func(T curve.G1Affine, g1proofs curve.G1Affine, transcript []fr.Element) curve.G1Affine {
		var res curve.G1Affine

		g1_list := make([]curve.G1Affine, 1)
		g1_list[0].Set(&T)

		res.MultiExp(g1_list, transcript, ecc.MultiExpConfig{})
		res.Add(&g1proofs, &res)
		return res
	}


	hf := sha256.New()
	transcript, err := Derivechall(prodproof.G1proofs, hf)
	if err != nil {
		fmt.Println(err)
	}

	transcriptlist := make([]fr.Element, 1)
	transcriptlist[0].Set(&transcript)

	leftside := make([]curve.G1Affine, 3)
	leftside[0] = computeleftside(T_a, prodproof.G1proofs[0], transcriptlist)
	leftside[1] = computeleftside(T_b, prodproof.G1proofs[1], transcriptlist)
	leftside[2] = computeleftside(T_c, prodproof.G1proofs[2], transcriptlist)

	for i := 0; i < 3; i++ {
		if !leftside[i].Equal(&rightside[i]) {
			fmt.Println("Product check fails!", i)
			result = false
		}
	}

	return result
}



// // Marshal

// func (pk *ProvingKey) writeTo(enc *curve.Encoder) (int64, error) {
// 	if err := enc.Encode(pk.Basis); err != nil {
// 		return enc.BytesWritten(), err
// 	}

// 	err := enc.Encode(pk.G)
// 	err = enc.Encode(pk.H)

// 	return enc.BytesWritten(), err
// }

// func (pk *ProvingKey) WriteTo(w io.Writer) (int64, error) {
// 	return pk.writeTo(curve.NewEncoder(w))
// }

// func (pk *ProvingKey) WriteRawTo(w io.Writer) (int64, error) {
// 	return pk.writeTo(curve.NewEncoder(w, curve.RawEncoding()))
// }

// func (pk *ProvingKey) ReadFrom(r io.Reader) (int64, error) {
// 	dec := curve.NewDecoder(r)

// 	if err := dec.Decode(&pk.Basis); err != nil {
// 		return dec.BytesRead(), err
// 	}
// 	if err := dec.Decode(&pk.H); err != nil {
// 		return dec.BytesRead(), err
// 	}
// 	if err := dec.Decode(&pk.G); err != nil {
// 		return dec.BytesRead(), err
// 	}

// 	// if cL, pL := len(pk.basis), len(pk.basisExpSigma); cL != pL {
// 	// 	return dec.BytesRead(), fmt.Errorf("commitment basis size (%d) doesn't match proof basis size (%d)", cL, pL)
// 	// }

// 	return dec.BytesRead(), nil
// }

type Triples struct {
	A []fr.Element
	B []fr.Element
	C []fr.Element
}

// // func (vk *VerifyingKey) WriteTo(w io.Writer) (int64, error) {
// // 	return vk.writeTo(curve.NewEncoder(w))
// // }

// // func (vk *VerifyingKey) WriteRawTo(w io.Writer) (int64, error) {
// // 	return vk.writeTo(curve.NewEncoder(w, curve.RawEncoding()))
// // }

// // func (vk *VerifyingKey) writeTo(enc *curve.Encoder) (int64, error) {
// // 	var err error

// // 	if err = enc.Encode(&vk.g); err != nil {
// // 		return enc.BytesWritten(), err
// // 	}
// // 	err = enc.Encode(&vk.gRootSigmaNeg)
// // 	return enc.BytesWritten(), err
// // }

// // func (vk *VerifyingKey) ReadFrom(r io.Reader) (int64, error) {
// // 	return vk.readFrom(r)
// // }

// // func (vk *VerifyingKey) UnsafeReadFrom(r io.Reader) (int64, error) {
// // 	return vk.readFrom(r, curve.NoSubgroupChecks())
// // }

// // func (vk *VerifyingKey) readFrom(r io.Reader, decOptions ...func(*curve.Decoder)) (int64, error) {
// // 	dec := curve.NewDecoder(r, decOptions...)
// // 	var err error

// // 	if err = dec.Decode(&vk.g); err != nil {
// // 		return dec.BytesRead(), err
// // 	}
// // 	err = dec.Decode(&vk.gRootSigmaNeg)
// // 	return dec.BytesRead(), err
// // }

// // WriteTo writes binary encoding of a ZeroKnowledgeOpeningProof
// func (proof *ProdProof) WriteTo(w io.Writer) (int64, error) {
// 	enc := curve.NewEncoder(w)

// 	toEncode := []interface{}{
// 		&proof.G1proofs,
// 		&proof.Frproofs,
// 	}

// 	for _, v := range toEncode {
// 		if err := enc.Encode(v); err != nil {
// 			return enc.BytesWritten(), err
// 		}
// 	}

// 	return enc.BytesWritten(), nil
// }

// // ReadFrom decodes ZeroKnowledgeOpeningProof data from reader.
// func (proof *ProdProof) ReadFrom(r io.Reader) (int64, error) {
// 	dec := curve.NewDecoder(r)

// 	toDecode := []interface{}{
// 		&proof.G1proofs,
// 		&proof.Frproofs,
// 	}

// 	for _, v := range toDecode {
// 		if err := dec.Decode(v); err != nil {
// 			return dec.BytesRead(), err
// 		}
// 	}

// 	return dec.BytesRead(), nil
// }


// // WriteTo writes binary encoding of a ZeroKnowledgeOpeningProof
// func (triples *Triples) WriteTo(w io.Writer) (int64, error) {
// 	enc := curve.NewEncoder(w)

// 	toEncode := []interface{}{
// 		&triples.A,
// 		&triples.B,
// 		&triples.C,
// 	}

// 	for _, v := range toEncode {
// 		if err := enc.Encode(v); err != nil {
// 			return enc.BytesWritten(), err
// 		}
// 	}

// 	return enc.BytesWritten(), nil
// }

// // ReadFrom decodes ZeroKnowledgeOpeningProof data from reader.
// func (triples *Triples) ReadFrom(r io.Reader) (int64, error) {
// 	dec := curve.NewDecoder(r)

// 	toDecode := []interface{}{
// 		&triples.A,
// 		&triples.B,
// 		&triples.C,
// 	}

// 	for _, v := range toDecode {
// 		if err := dec.Decode(v); err != nil {
// 			return dec.BytesRead(), err
// 		}
// 	}

// 	return dec.BytesRead(), nil
// }


